<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISRO Flight Dynamics & Orbital Tracker</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@400;600;800&display=swap');

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body, html {
            width: 100vw; height: 100vh; background-color: #050b14;
            font-family: 'Inter', sans-serif; color: #94a3b8;
            display: flex; flex-direction: column; overflow: hidden; user-select: none;
        }

        /* --- HEADER --- */
        #header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px 30px; border-bottom: 1px solid #1e293b; background: #0b1320;
        }
        .header-title { display: flex; align-items: center; gap: 15px; font-family: 'Share Tech Mono', monospace; font-size: 18px; color: #f8fafc; letter-spacing: 2px;}
        .header-title span.indicator { height: 10px; width: 10px; background: #10b981; border-radius: 50%; box-shadow: 0 0 10px #10b981; }
        .header-status { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: #38bdf8; display: flex; gap: 20px;}

        /* --- DASHBOARD GRID --- */
        #dashboard {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;
            padding: 15px 30px; background: #050b14; border-bottom: 1px solid #1e293b; z-index: 10;
        }
        
        .data-card { background: #0b1320; border: 1px solid #1e293b; border-radius: 6px; padding: 12px 20px; display: flex; flex-direction: column; justify-content: space-between; box-shadow: inset 0 0 20px rgba(0,0,0,0.5); }
        .card-label { font-size: 11px; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; }
        .card-value { font-family: 'Share Tech Mono', monospace; font-size: 24px; color: #38bdf8; text-shadow: 0 0 15px rgba(56, 189, 248, 0.3);}
        .card-value.white { color: #f8fafc; text-shadow: none; }
        .card-value.green { color: #10b981; text-shadow: 0 0 15px rgba(16, 185, 129, 0.3); }
        .card-unit { font-size: 14px; color: #94a3b8; }
        .card-sub { font-size: 12px; color: #64748b; margin-top: 5px; font-family: 'Share Tech Mono', monospace;}

        .progress-container { width: 100%; height: 4px; background: #1e293b; border-radius: 2px; margin-top: 8px; overflow: hidden;}
        .progress-bar { height: 100%; background: #10b981; width: 100%; transition: width 0.1s linear;}
        .progress-bar.cyan { background: #38bdf8; width: 0%;}

        /* --- NAV & VIEWS --- */
        #top-nav {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 50;
            background: rgba(11, 19, 32, 0.9); padding: 5px; border-radius: 4px; border: 1px solid #1e293b; backdrop-filter: blur(5px);
        }
        .nav-btn { border: 1px solid transparent; color: #64748b; padding: 10px 20px; background: transparent; font-size: 13px; cursor: pointer; font-family: 'Share Tech Mono', monospace; letter-spacing: 1px;}
        .nav-btn:hover { background: rgba(56, 189, 248, 0.1); }
        .nav-btn.active { border-color: #38bdf8; color: #38bdf8; background: rgba(56, 189, 248, 0.15); box-shadow: 0 0 10px rgba(56, 189, 248, 0.2) inset; }

        /* Unified WebGL Container */
        #main-view { flex-grow: 1; position: relative; background: #000; overflow: hidden; }
        #webgl-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; cursor: grab; }
        #webgl-container:active { cursor: grabbing; }
        
        #radar-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; display: none; background: radial-gradient(circle at center, #02050a 0%, #000000 100%); }
        #radar-canvas { width: 100%; height: 100%; display: block; }

        /* --- UI OVERLAYS --- */
        .overlay-panel { position: absolute; background: rgba(11, 19, 32, 0.85); border: 1px solid #1e293b; padding: 20px; border-radius: 8px; backdrop-filter: blur(8px); z-index: 10; font-family: 'Share Tech Mono', monospace; }
        .overlay-panel h4 { color: #f8fafc; margin-bottom: 15px; font-size: 14px; letter-spacing: 1px; border-bottom: 1px solid #38bdf8; padding-bottom: 5px;}
        
        #timeline { top: 30px; left: 30px; width: 280px; }
        .event-item { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; color: #64748b; font-size: 12px; transition: 0.3s;}
        .event-dot { width: 10px; height: 10px; border-radius: 50%; border: 2px solid #64748b; background: transparent; transition: 0.3s;}
        .event-item.active { color: #38bdf8; text-shadow: 0 0 8px rgba(56,189,248,0.5); font-weight: bold;}
        .event-item.active .event-dot { border-color: #38bdf8; background: #38bdf8; box-shadow: 0 0 10px #38bdf8;}
        .event-item.completed { color: #10b981; }
        .event-item.completed .event-dot { border-color: #10b981; background: #10b981;}

        #traj-controls { top: 30px; right: 30px; width: 320px; border-color: #38bdf8;}
        .ctrl-row { margin-bottom: 15px; }
        .ctrl-label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 5px; color: #f8fafc; }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #38bdf8; cursor: pointer; margin-top: -5px; box-shadow: 0 0 8px #38bdf8; border: 2px solid #000; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #1e293b; border-radius: 2px; }

        .controls { position: absolute; bottom: 30px; left: 30px; z-index: 50; display: flex; gap: 10px; }
        button { background: rgba(16, 185, 129, 0.1); border: 1px solid #10b981; color: #10b981; padding: 12px 20px; font-family: 'Share Tech Mono', monospace; font-size: 13px; border-radius: 4px; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; box-shadow: 0 0 15px rgba(16, 185, 129, 0.2); transition: 0.2s; }
        button:hover { background: #10b981; color: #000; }
        button.btn-abort { background: rgba(239, 68, 68, 0.1); border-color: #ef4444; color: #ef4444; box-shadow: none; }
        button.btn-abort:hover { background: #ef4444; color: #fff; }
        button.btn-cam { background: rgba(56, 189, 248, 0.1); border-color: #38bdf8; color: #38bdf8; box-shadow: none;}
        button.btn-cam:hover { background: #38bdf8; color: #000;}
        button.btn-skip { background: rgba(245, 158, 11, 0.1); border-color: #f59e0b; color: #f59e0b; box-shadow: none; display: none;}
        button.btn-skip:hover { background: #f59e0b; color: #000; }

        .legend { position: absolute; bottom: 30px; right: 30px; background: rgba(11, 19, 32, 0.85); border: 1px solid #1e293b; padding: 15px; border-radius: 6px; font-family: 'Share Tech Mono', monospace; font-size: 11px; line-height: 1.8; color: #94a3b8; pointer-events: none; backdrop-filter: blur(4px); z-index: 10;}
    </style>
</head>
<body>

    <header id="header">
        <div class="header-title">
            <span class="indicator" id="status-dot"></span>
            ISRO FLIGHT DYNAMICS
            <span class="header-sub">ORBITAL TRAJECTORY TRACKING</span>
        </div>
        <div class="header-status">
            <span>UNIFIED PHYSICS ENGINE</span>
            <span id="sys-status" style="color: #64748b; margin-left: 10px;">STANDBY</span>
        </div>
    </header>

    <section id="dashboard">
        <div class="data-card">
            <div class="card-label">MISSION TIME</div>
            <div class="card-value white" id="ui-time">T-00:00</div>
        </div>
        <div class="data-card">
            <div class="card-label">ALTITUDE</div>
            <div class="card-value white"><span id="ui-alt">0.00</span> <span class="card-unit">km</span></div>
            <div class="card-sub">V/S <span id="ui-vs">0</span> m/s</div>
        </div>
        <div class="data-card">
            <div class="card-label">VELOCITY</div>
            <div class="card-value"><span id="ui-vel">0</span> <span class="card-unit">m/s</span></div>
            <div class="card-sub">MACH <span id="ui-mach">0.00</span></div>
        </div>
        <div class="data-card">
            <div class="card-label">DYNAMIC PRESSURE</div>
            <div class="card-value white"><span id="ui-q">0.0</span> <span class="card-unit">kPa</span></div>
            <div class="card-sub">ACCEL: <span id="ui-accel">1.00</span> G</div>
        </div>
        <div class="data-card">
            <div class="card-label">TOTAL VEHICLE MASS</div>
            <div class="card-value"><span id="ui-mass">420.0</span> <span class="card-unit">t</span></div>
            <div class="progress-container"><div class="progress-bar" id="ui-fuel-bar"></div></div>
        </div>
        <div class="data-card">
            <div class="card-label">ORBITAL VELOCITY</div>
            <div class="card-value"><span id="ui-orbitv">0.0</span> <span class="card-unit">%</span></div>
            <div class="progress-container"><div class="progress-bar cyan" id="ui-orbit-bar"></div></div>
        </div>
        <div class="data-card" style="border-color: #10b981; background: rgba(16, 185, 129, 0.05); grid-column: span 2;">
            <div style="display:flex; justify-content: space-between;">
                <div class="card-label" style="color: #10b981;">GROUND RADAR: DOPPLER SHIFT</div>
                <div class="card-label" style="color: #64748b;">FREQ: 10GHz X-BAND</div>
            </div>
            <div style="display:flex; justify-content: space-between; align-items: flex-end;">
                <div class="card-value green"><span id="ui-dop-shift">0.00</span> <span class="card-unit" style="color:#10b981">Hz</span></div>
                <div class="card-sub" style="color: #94a3b8; font-size:14px;">PATH DEVIATION: <span id="ui-dop-err" style="color:#10b981; font-weight:bold;">0.00</span> m/s</div>
            </div>
        </div>
    </section>

    <main id="main-view">
        <div id="top-nav">
            <button class="nav-btn active" id="btn-tab-launch" onclick="switchTab('launch')">3D FLIGHT TRACKER</button>
            <button class="nav-btn" id="btn-tab-orbit" onclick="switchTab('orbit')">ORBITAL VIEW</button>
            <button class="nav-btn" id="btn-tab-radar" onclick="switchTab('radar')">TACTICAL RADAR</button>
        </div>

        <div id="webgl-container"></div>
        <div id="radar-container"><canvas id="radar-canvas"></canvas></div>
        
        <div class="overlay-panel" id="timeline">
            <h4>FLIGHT EVENTS</h4>
            <div class="event-item active" id="ev-0"><div class="event-dot"></div>PRE-LAUNCH SETUP</div>
            <div class="event-item" id="ev-1"><div class="event-dot"></div>LIFTOFF</div>
            <div class="event-item" id="ev-2"><div class="event-dot"></div>MAX-Q (Max Aero Pressure)</div>
            <div class="event-item" id="ev-3"><div class="event-dot"></div>SRB SEPARATION</div>
            <div class="event-item" id="ev-4"><div class="event-dot"></div>MECO (Stage 1 Cutoff)</div>
            <div class="event-item" id="ev-5"><div class="event-dot"></div>STAGE 2 IGNITION</div>
            <div class="event-item" id="ev-6"><div class="event-dot"></div>FAIRING DEPLOYMENT</div>
            <div class="event-item" id="ev-7"><div class="event-dot"></div>ORBIT INSERTION</div>
            <div class="event-item" id="ev-8"><div class="event-dot"></div>PAYLOAD DEPLOYMENT</div>
        </div>

        <div class="overlay-panel" id="traj-controls">
            <h4>PREDICTIVE TRAJECTORY SHAPING</h4>
            <div class="ctrl-row">
                <div class="ctrl-label"><span>GRAVITY TURN KICK ALT (m)</span><span id="lbl-kick" style="color:#38bdf8">1500</span></div>
                <input type="range" id="inp-kick" min="500" max="10000" step="100" value="1500">
            </div>
            <div class="ctrl-row">
                <div class="ctrl-label"><span>PITCH AGGRESSIVENESS</span><span id="lbl-aggro" style="color:#38bdf8">0.85</span></div>
                <input type="range" id="inp-aggro" min="0.3" max="1.5" step="0.01" value="0.85">
            </div>
            <div style="font-size: 10px; color: #64748b; margin-top: 10px; text-align:center; line-height:1.4;">
                Adjustments compute instantly. Rocket mathematically locks to the center vector.
            </div>
        </div>

        <div class="controls" id="btn-controls">
            <button onclick="triggerLaunch()" id="btn-launch">INITIATE LAUNCH</button>
            <button onclick="skipToNextStage()" class="btn-skip" id="btn-skip">FAST FORWARD >></button>
            <button onclick="resetLaunch()" class="btn-abort">RESET</button>
            <button onclick="cycleCamera()" class="btn-cam" id="btn-cam">CAM: CINEMATIC</button>
        </div>

        <div class="legend" id="legend-box">
            <span style="color:#38bdf8; font-weight:bold;">--- PREDICTED PATH (MATH)</span><br>
            <span style="color:#f59e0b; font-weight:bold;">--- LIVE FLIGHT PATH (RK4)</span><br>
            <span style="color:#10b981; font-weight:bold;">▲ GROUND RADAR STATION</span>
        </div>
    </main>

    <script>
        // ==================================================================
        // 1. DETERMINISTIC PHYSICS & TRAJECTORY ENGINE
        // ==================================================================
        const G0 = 9.80665; 
        const EARTH_R = 6371000;
        const ORBITAL_V = 7800; 
        const RADAR_FREQ = 10e9; 
        const C_SPEED = 3e8;
        const FIXED_DT = 0.05; 

        let simActive = false;
        let simStartTime = 0; 
        let masterTrajectory = []; 
        let simState = null; 
        
        let currentTab = 'launch'; 
        let camMode = 0; // 0=Cinematic, 1=Engine, 2=Pad

        // OPIMIZATION: Use 'change' event to prevent calculating 13000 steps during drag
        document.getElementById('inp-kick').addEventListener('change', (e) => { if(!simActive) generateTrajectory(); });
        document.getElementById('inp-kick').addEventListener('input', (e) => { document.getElementById('lbl-kick').innerText = e.target.value; });
        
        document.getElementById('inp-aggro').addEventListener('change', (e) => { if(!simActive) generateTrajectory(); });
        document.getElementById('inp-aggro').addEventListener('input', (e) => { document.getElementById('lbl-aggro').innerText = e.target.value; });

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-tab-' + tab).classList.add('active');

            // UI Overlays toggling
            let isLaunch = (tab === 'launch');
            document.getElementById('webgl-container').style.display = (tab === 'radar') ? 'none' : 'block';
            document.getElementById('radar-container').style.display = (tab === 'radar') ? 'block' : 'none';
            document.getElementById('traj-controls').style.display = isLaunch ? 'block' : 'none';
            document.getElementById('btn-controls').style.display = isLaunch ? 'flex' : 'none';

            let lgd = document.getElementById('legend-box');
            if(tab === 'launch') lgd.innerHTML = '<span style="color:#38bdf8; font-weight:bold;">--- PREDICTED PATH (MATH)</span><br><span style="color:#f59e0b; font-weight:bold;">--- LIVE FLIGHT PATH (RK4)</span><br><span style="color:#10b981; font-weight:bold;">▲ GROUND RADAR STATION</span>';
            if(tab === 'orbit') lgd.innerHTML = '<span style="color:#f8fafc; font-weight:bold;">GLOBAL ORBITAL MONITOR</span><br><span style="color:#00f0ff;">■ SATELLITE PAYLOAD</span><br><span style="color:#38bdf8;">--- ORBITAL INSERTION TRAJECTORY</span>';
            if(tab === 'radar') {
                lgd.innerHTML = '<span style="color:#00f0ff; font-weight:bold;">■ PRIMARY ASSET (ROCKET)</span><br><span style="color:#ff2a2a; font-weight:bold;">■ GROUND STATION</span>';
                let cvs = document.getElementById('radar-canvas');
                cvs.width = document.getElementById('radar-container').clientWidth;
                cvs.height = document.getElementById('radar-container').clientHeight;
            }
        }

        // FLAWLESS MATH: Precomputes the entire flight completely avoiding NaN errors
        function generateTrajectory() {
            masterTrajectory = [];
            let kickAlt = parseFloat(document.getElementById('inp-kick').value);
            let aggro = parseFloat(document.getElementById('inp-aggro').value);

            let state = {
                t: 0, x: 0, y: 0, vx: 0, vy: 0, v: 0, 
                pitch: Math.PI / 2, 
                mass: 420000, fuel: 350000, fuel0: 350000, 
                thrustKN: 0, dynQ: 0, mach: 0, accel: 1,
                doppler: 0, gsX: -3000, gsY: 0, 
                event: 0 
            };

            for(let t=0; t<=650; t += FIXED_DT) {
                let thrustN = 0;
                let currentEvent = state.event;

                // ABSOLUTE MATH CLAMPING
                if (state.fuel < 0) state.fuel = 0;
                if (state.mass < 2000) state.mass = 2000;

                // STAGING LOGIC WITH MASS DROPS
                if (t > 0 && t < 120) { thrustN = 6800000; currentEvent = 1; } 
                if (t >= 120 && t < 120.1 && state.event < 3) { currentEvent = 3; state.mass = Math.max(2000, state.mass - 35000); } 
                if (t >= 120 && t < 150 && state.fuel > 0) { thrustN = 2500000; currentEvent = 3; } 
                if (t >= 150 && t <= 155) { thrustN = 0; currentEvent = 4; } 
                if (t >= 155 && t < 155.1 && state.event < 5) { currentEvent = 5; state.mass = Math.max(2000, state.mass - 25000); } 
                if (t > 155 && t < 380 && state.fuel > 0) { thrustN = 1200000; currentEvent = 5; } 
                if (t >= 180 && t < 180.1 && state.event < 6) { currentEvent = 6; state.mass = Math.max(2000, state.mass - 2000); } 
                if (t >= 380 && t < 400) { thrustN = 0; currentEvent = 7; } // Orbit Coast
                if (t >= 400) { thrustN = 0; currentEvent = 8; } // PAYLOAD DEPLOYMENT

                state.event = currentEvent;

                // Gravity Turn
                let targetPitch = Math.PI / 2;
                if (state.y > kickAlt && thrustN > 0) {
                    let turnFactor = Math.min(1, (state.y - kickAlt) / 150000);
                    targetPitch = (Math.PI / 2) * (1 - turnFactor * aggro);
                }
                state.pitch += (targetPitch - state.pitch) * 0.04;

                if (thrustN > 0) {
                    let massFlow = thrustN / (300 * G0); 
                    let burned = massFlow * FIXED_DT;
                    if(state.fuel < burned) burned = state.fuel; 
                    state.fuel -= burned; state.mass -= burned;
                    if(state.mass < 2000) state.mass = 2000; 
                }

                state.v = Math.sqrt(state.vx*state.vx + state.vy*state.vy);
                let rho = 1.225 * Math.exp(-state.y / 8500); 
                let speedOfSound = Math.max(295, 340 - (state.y/1000 * 4));
                state.mach = state.v / speedOfSound;
                
                state.dynQ = 0.5 * rho * (state.v * state.v);
                let dragForce = state.dynQ * 15.0 * 0.4; 
                if(state.dynQ > 30000 && state.event === 1) state.event = 2;

                let flightPathAngle = (state.v > 1) ? Math.atan2(state.vy, state.vx) : state.pitch;
                
                // ORBITAL CENTRIFUGAL FIX
                let centrifugalAccel = (state.vx * state.vx) / (EARTH_R + state.y);
                let effectiveGravity = Math.max(0, G0 - centrifugalAccel);

                let fx = (Math.cos(state.pitch) * thrustN) - (Math.cos(flightPathAngle) * dragForce);
                let fy = (Math.sin(state.pitch) * thrustN) - (Math.sin(flightPathAngle) * dragForce) - (state.mass * effectiveGravity);

                let ax = fx / state.mass; let ay = fy / state.mass;
                
                // Once in orbit, lock trajectory mathematically flat
                if (state.event >= 7) { ay = 0; state.vy *= 0.95; state.pitch = 0; }

                state.accel = Math.sqrt(ax*ax + (ay+G0)*(ay+G0)) / G0; 

                state.vx += ax * FIXED_DT; state.vy += ay * FIXED_DT;
                state.x += state.vx * FIXED_DT; state.y += state.vy * FIXED_DT;
                state.thrustKN = thrustN / 1000;

                let dx = state.x - state.gsX; let dy = state.y - state.gsY;
                let slantRange = Math.sqrt(dx*dx + dy*dy);
                let vRad = slantRange > 0 ? ((dx * state.vx) + (dy * state.vy)) / slantRange : 0;
                state.doppler = (-2 * vRad * RADAR_FREQ) / C_SPEED;

                masterTrajectory.push({...state, t: t}); 
            }
            
            drawOptimalPaths();
            simState = masterTrajectory[0];
            updateDashboard();
        }

        // ==================================================================
        // 2. DOM UI UPDATES
        // ==================================================================
        function updateDashboard() {
            if(!simState) return;

            let mins = Math.floor(simState.t / 60);
            let secs = (simState.t % 60).toFixed(1).padStart(4, '0');
            document.getElementById('ui-time').innerText = `T+${mins}:${secs}`;
            document.getElementById('ui-alt').innerText = (simState.y / 1000).toFixed(2);
            document.getElementById('ui-vs').innerText = simState.vy.toFixed(0);
            document.getElementById('ui-vel').innerText = simState.v.toFixed(0);
            document.getElementById('ui-mach').innerText = simState.mach.toFixed(2);
            document.getElementById('ui-accel').innerText = simState.accel.toFixed(2);
            document.getElementById('ui-q').innerText = (simState.dynQ / 1000).toFixed(1);
            
            document.getElementById('ui-mass').innerText = (simState.mass / 1000).toFixed(1);
            document.getElementById('ui-fuel-bar').style.width = `${(simState.fuel / simState.fuel0) * 100}%`;
            
            let ovPct = Math.min(100, (simState.v / ORBITAL_V) * 100);
            document.getElementById('ui-orbitv').innerText = ovPct.toFixed(1);
            document.getElementById('ui-orbit-bar').style.width = `${ovPct}%`;

            document.getElementById('ui-dop-shift').innerText = simState.doppler.toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1});
            
            // Artificial Jitter for UI. Engine math is perfect 0.
            let sensorNoise = simState.thrustKN > 0 ? (Math.random() - 0.5) * 0.05 : 0.00;
            document.getElementById('ui-dop-err').innerText = Math.abs(sensorNoise).toFixed(2);
            
            updateTimelineUI(simState.event);
        }

        function updateTimelineUI(eventIndex) {
            for(let i=0; i<=8; i++) {
                let el = document.getElementById(`ev-${i}`);
                if(!el) continue;
                if(i < eventIndex) el.className = "event-item completed";
                else if (i === eventIndex) el.className = "event-item active";
                else el.className = "event-item";
            }
        }

        // ==================================================================
        // 3. UNIFIED 3D GRAPHICS ENGINE (Massive Optimization)
        // ==================================================================
        let renderer;
        
        // Launch Scene Objects
        let sceneL, camL, ctrlL, rocketGroup, exhaustPts, engineLight, payloadSpotlight;
        let optTrailL, actTrailL, actTrailGeoL;
        
        // Orbit Scene Objects
        let sceneO, camO, ctrlO, earthGroup, orbitSatGroup;
        let optTrailO, actTrailO, actTrailGeoO;
        
        let actPts = []; let oActPts = [];

        function createParticleTexture() {
            let canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; let ctx = canvas.getContext('2d');
            let grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)'); grad.addColorStop(0.2, 'rgba(255, 200, 50, 1)'); grad.addColorStop(0.5, 'rgba(255, 50, 0, 0.8)'); grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,64,64); return new THREE.CanvasTexture(canvas);
        }

        function buildProceduralRocket() {
            const grp = new THREE.Group();
            const matBody = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.3});
            const matDark = new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.8});
            const matGold = new THREE.MeshStandardMaterial({color: 0xffd700, roughness: 0.2, metalness: 1.0}); 
            const matSolar = new THREE.MeshStandardMaterial({color: 0x004488, roughness: 0.1, metalness: 0.6});

            const stage1 = new THREE.Mesh(new THREE.CylinderGeometry(1.8, 1.8, 40, 32), matBody); stage1.position.y = 20;
            const stripe = new THREE.Mesh(new THREE.CylinderGeometry(1.81, 1.81, 4, 32), matDark); stripe.position.y = 10; stage1.add(stripe);
            
            const interstage = new THREE.Mesh(new THREE.CylinderGeometry(1.8, 1.8, 6, 32), matDark); interstage.position.y = 43;
            const stage2 = new THREE.Mesh(new THREE.CylinderGeometry(1.8, 1.8, 15, 32), matBody); stage2.position.y = 53.5;
            
            for(let i=0; i<9; i++) {
                let bell = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.5, 16, 1, true), matDark);
                let a = (i/8) * Math.PI * 2; let r = i === 8 ? 0 : 1.0; 
                bell.position.set(Math.cos(a)*r, -20.75, Math.sin(a)*r); bell.rotation.x = Math.PI;
                stage1.add(bell); 
            }
            let s2Bell = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2.0, 16, 1, true), matDark); s2Bell.position.y = -8.5; s2Bell.rotation.x = Math.PI; stage2.add(s2Bell);

            const srbL = new THREE.Group(); const srbR = new THREE.Group();
            srbL.position.set(-2.6, 15, 0); srbR.position.set(2.6, 15, 0);
            const srbBody = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 25, 32), matBody);
            const srbNose = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2.5, 32), matBody); srbNose.position.y = 13.75;
            srbL.add(srbBody.clone(), srbNose.clone()); srbR.add(srbBody, srbNose);

            // HUGE SATELLITE
            const payload = new THREE.Group();
            const satBody = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 3), matGold);
            const panelL = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 0.2), matSolar); panelL.geometry.translate(-5, 0, 0); panelL.position.x = -1.5;
            const panelR = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 0.2), matSolar); panelR.geometry.translate(5, 0, 0); panelR.position.x = 1.5;
            payload.add(satBody, panelL, panelR); payload.position.y = 66;
            
            payloadSpotlight = new THREE.PointLight(0xffffff, 0, 200); payloadSpotlight.position.set(0, 10, 10); payload.add(payloadSpotlight);

            const fairingL = new THREE.Group(); const fairingR = new THREE.Group();
            const fBaseGeoL = new THREE.CylinderGeometry(3.2, 1.8, 4, 16, 1, false, 0, Math.PI); const fBodyGeoL = new THREE.CylinderGeometry(3.2, 3.2, 10, 16, 1, false, 0, Math.PI); const fNoseGeoL = new THREE.ConeGeometry(3.2, 8, 16, 1, false, 0, Math.PI);
            const fBaseGeoR = new THREE.CylinderGeometry(3.2, 1.8, 4, 16, 1, false, Math.PI, Math.PI); const fBodyGeoR = new THREE.CylinderGeometry(3.2, 3.2, 10, 16, 1, false, Math.PI, Math.PI); const fNoseGeoR = new THREE.ConeGeometry(3.2, 8, 16, 1, false, Math.PI, Math.PI);

            let fBaseL = new THREE.Mesh(fBaseGeoL, matBody); fBaseL.position.y = 63; let fBodyL = new THREE.Mesh(fBodyGeoL, matBody); fBodyL.position.y = 70; let fNoseL = new THREE.Mesh(fNoseGeoL, matBody); fNoseL.position.y = 79; fairingL.add(fBaseL, fBodyL, fNoseL);
            let fBaseR = new THREE.Mesh(fBaseGeoR, matBody); fBaseR.position.y = 63; let fBodyR = new THREE.Mesh(fBodyGeoR, matBody); fBodyR.position.y = 70; let fNoseR = new THREE.Mesh(fNoseGeoR, matBody); fNoseR.position.y = 79; fairingR.add(fBaseR, fBodyR, fNoseR);

            grp.add(stage1, interstage, stage2, srbL, srbR, payload, fairingL, fairingR);
            grp.traverse(child => { if(child.isMesh){ child.castShadow = true; child.receiveShadow = true; }});
            
            grp.userData = { srbL: srbL, srbR: srbR, fairingL: fairingL, fairingR: fairingR, stage1: stage1, interstage: interstage, stage2: stage2, payload: payload };
            return grp;
        }

        function drawOptimalPaths() {
            if(optTrailL) sceneL.remove(optTrailL);
            if(optTrailO) sceneO.remove(optTrailO);
            
            let lPts = []; let oPts = []; let rScale = 100 / 6371;

            for(let i=0; i<masterTrajectory.length; i+=10) { 
                let s = masterTrajectory[i];
                lPts.push(new THREE.Vector3(s.x / 10, s.y / 10 + 2, 0)); 
                let r = 100 + ((s.y/1000) * rScale * 2.5); // Visual multiplier to see orbit
                let theta = (s.x/1000) / 6371; 
                oPts.push(new THREE.Vector3(Math.sin(theta)*r, Math.cos(theta)*r, 0));
            }
            
            // Draw Full Global Ring in Orbit View
            let lastS = masterTrajectory[masterTrajectory.length-1];
            if(lastS) {
                let finalR = 100 + ((lastS.y/1000) * rScale * 2.5);
                let startTheta = (lastS.x/1000) / 6371;
                for(let a=startTheta; a<=Math.PI*2 + startTheta; a+=0.1) oPts.push(new THREE.Vector3(Math.sin(a)*finalR, Math.cos(a)*finalR, 0));
            }

            optTrailL = new THREE.Line(new THREE.BufferGeometry().setFromPoints(lPts), new THREE.LineBasicMaterial({ color: 0x38bdf8, transparent: true, opacity: 0.4, linewidth: 2 }));
            sceneL.add(optTrailL);

            optTrailO = new THREE.Line(new THREE.BufferGeometry().setFromPoints(oPts), new THREE.LineBasicMaterial({ color: 0x38bdf8, transparent: true, opacity: 0.5, linewidth: 2 }));
            sceneO.add(optTrailO);
        }

        function initWebGL() {
            const cont = document.getElementById('webgl-container');
            let w = cont.clientWidth; let h = cont.clientHeight;

            renderer = new THREE.WebGLRenderer({antialias: true, powerPreference: "high-performance"});
            renderer.setSize(w, h); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true;
            cont.appendChild(renderer.domElement);

            // --- BUILD LAUNCH SCENE ---
            sceneL = new THREE.Scene(); sceneL.background = new THREE.Color(0x02050a); sceneL.fog = new THREE.FogExp2(0x02050a, 0.0001);
            camL = new THREE.PerspectiveCamera(45, w/h, 1, 100000);
            ctrlL = new THREE.OrbitControls(camL, renderer.domElement); ctrlL.enableDamping = true; ctrlL.maxPolarAngle = Math.PI/2 - 0.02;

            sceneL.add(new THREE.AmbientLight(0x334155, 1.5));
            let sunL = new THREE.DirectionalLight(0xffffff, 2.5); sunL.position.set(200, 500, 200); sunL.castShadow = true; sceneL.add(sunL);

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(20000, 20000), new THREE.MeshStandardMaterial({color: 0x0a0f1a, roughness: 1})); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; sceneL.add(ground);
            const grid = new THREE.GridHelper(20000, 400, 0x1e293b, 0x1e293b); grid.position.y = 0.2; sceneL.add(grid);
            const pad = new THREE.Mesh(new THREE.BoxGeometry(60, 5, 60), new THREE.MeshStandardMaterial({color: 0x334155})); pad.position.y = 2.5; pad.receiveShadow = true; pad.castShadow = true; sceneL.add(pad);
            const radar = new THREE.Mesh(new THREE.SphereGeometry(4, 16, 16, 0, Math.PI*2, 0, Math.PI/2), new THREE.MeshBasicMaterial({color: 0x10b981, wireframe: true})); radar.position.set(-300, 0, 0); sceneL.add(radar);

            rocketGroup = buildProceduralRocket(); rocketGroup.position.y = 5; sceneL.add(rocketGroup);

            engineLight = new THREE.PointLight(0xf59e0b, 0, 800); engineLight.position.set(0, -5, 0); engineLight.castShadow = true; rocketGroup.add(engineLight);

            let exGeo = new THREE.BufferGeometry(); let exPos = new Float32Array(1500 * 3); exGeo.setAttribute('position', new THREE.BufferAttribute(exPos, 3));
            let exMat = new THREE.PointsMaterial({color: 0xffffff, size: 10, map: createParticleTexture(), transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false});
            exhaustPts = new THREE.Points(exGeo, exMat); sceneL.add(exhaustPts);

            actTrailGeoL = new THREE.BufferGeometry(); actTrailL = new THREE.Line(actTrailGeoL, new THREE.LineBasicMaterial({color: 0xf59e0b, linewidth: 4})); sceneL.add(actTrailL);


            // --- BUILD ORBIT SCENE ---
            sceneO = new THREE.Scene(); sceneO.background = new THREE.Color(0x02050a);
            camO = new THREE.PerspectiveCamera(45, w/h, 1, 10000); camO.position.set(0, 0, 400);
            ctrlO = new THREE.OrbitControls(camO, renderer.domElement); ctrlO.enableDamping = true;

            sceneO.add(new THREE.AmbientLight(0x222233)); let sunO = new THREE.DirectionalLight(0xffffff, 2); sunO.position.set(500, 200, 500); sceneO.add(sunO);

            // Procedural Tactical Earth (No image load crash)
            earthGroup = new THREE.Group();
            let eMesh = new THREE.Mesh(new THREE.SphereGeometry(100, 32, 32), new THREE.MeshPhongMaterial({color: 0x05101a, emissive: 0x020812, flatShading: false}));
            let eWire = new THREE.Mesh(new THREE.SphereGeometry(100.2, 32, 32), new THREE.MeshBasicMaterial({color: 0x00f0ff, wireframe: true, transparent: true, opacity: 0.15}));
            earthGroup.add(eMesh, eWire); earthGroup.rotation.x = 0.2; sceneO.add(earthGroup);

            orbitSatGroup = new THREE.Group();
            orbitSatGroup.add(new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({color: 0xffd700})));
            let pL = new THREE.Mesh(new THREE.BoxGeometry(4,1,0.1), new THREE.MeshStandardMaterial({color: 0x004488})); pL.position.x = -3;
            let pR = new THREE.Mesh(new THREE.BoxGeometry(4,1,0.1), new THREE.MeshStandardMaterial({color: 0x004488})); pR.position.x = 3;
            orbitSatGroup.add(pL, pR); sceneO.add(orbitSatGroup);

            actTrailGeoO = new THREE.BufferGeometry(); actTrailO = new THREE.Line(actTrailGeoO, new THREE.LineBasicMaterial({color: 0xf59e0b, linewidth: 3})); sceneO.add(actTrailO);

            window.addEventListener('resize', () => {
                let rw = document.getElementById('main-view').clientWidth; let rh = document.getElementById('main-view').clientHeight;
                if(!rw) return; 
                camL.aspect = rw/rh; camL.updateProjectionMatrix();
                camO.aspect = rw/rh; camO.updateProjectionMatrix();
                renderer.setSize(rw, rh);
            });
            
            generateTrajectory();
            resetLaunch();
            animate(); // Single Unified Loop
        }

        // ==================================================================
        // 4. LAUNCH CONTROLS
        // ==================================================================
        function cycleCamera() {
            camMode = (camMode + 1) % 3;
            let btn = document.getElementById('btn-cam');
            if(camMode === 0) { btn.innerText = "CAM: CINEMATIC"; btn.style.color = "#38bdf8"; }
            if(camMode === 1) { btn.innerText = "CAM: ENGINE"; btn.style.color = "#f59e0b"; }
            if(camMode === 2) { btn.innerText = "CAM: PAD TRACKING"; btn.style.color = "#10b981"; }
        }

        let uiInterval;
        function triggerLaunch() {
            if(simActive) return;
            document.getElementById('inp-kick').disabled = true; document.getElementById('inp-aggro').disabled = true;
            document.getElementById('btn-skip').style.display = "block";
            
            simActive = true;
            simStartTime = Date.now() - (masterTrajectory[0].t * 1000); 
            
            document.getElementById('sys-status').innerText = "SYSTEM ACTIVE";
            document.getElementById('sys-status').style.color = "#10b981";
            document.getElementById('status-dot').style.background = "#ef4444";
            document.getElementById('btn-launch').style.opacity = "0.5";
            
            uiInterval = setInterval(updateDashboard, 100); 
        }

        function resetLaunch() {
            simActive = false; clearInterval(uiInterval); currentTick = 0; hasAutoSwitchedToOrbit = false;
            document.getElementById('inp-kick').disabled = false; document.getElementById('inp-aggro').disabled = false;
            document.getElementById('btn-skip').style.display = "none";
            
            generateTrajectory(); 
            
            rocketGroup.position.set(0, 5, 0); rocketGroup.rotation.z = 0;
            rocketGroup.userData.srbL.position.set(-2.6, 15, 0); rocketGroup.userData.srbL.rotation.z = 0;
            rocketGroup.userData.srbR.position.set(2.6, 15, 0); rocketGroup.userData.srbR.rotation.z = 0;
            rocketGroup.userData.fairingL.position.set(0, 0, 0); rocketGroup.userData.fairingL.rotation.z = 0;
            rocketGroup.userData.fairingR.position.set(0, 0, 0); rocketGroup.userData.fairingR.rotation.z = 0;
            rocketGroup.userData.stage1.position.set(0, 20, 0); rocketGroup.userData.interstage.position.set(0, 43, 0);
            rocketGroup.userData.payload.position.set(0, 66, 0); rocketGroup.userData.payload.rotation.y = 0;
            rocketGroup.userData.payload.children[1].rotation.z = 0; rocketGroup.userData.payload.children[2].rotation.z = 0;
            payloadSpotlight.intensity = 0;

            engineLight.intensity = 0; exhaustPts.visible = false;
            actPts = []; actTrailGeoL.setFromPoints(actPts);
            oActPts = []; actTrailGeoO.setFromPoints(oActPts);
            
            document.getElementById('sys-status').innerText = "STANDBY";
            document.getElementById('sys-status').style.color = "#64748b";
            document.getElementById('btn-launch').style.opacity = "1";
            document.getElementById('status-dot').style.background = "#10b981";
            
            camMode = 0; document.getElementById('btn-cam').innerText = "CAM: CINEMATIC"; document.getElementById('btn-cam').style.color = "#38bdf8";
            camL.position.set(-100, 50, 200); ctrlL.target.set(0, 20, 0);
            updateDashboard();
            switchTab('launch');
        }

        // PERFECT CLOCK SYNC SKIP
        function skipToNextStage() {
            if(!simActive || !simState) return;
            let currentEv = simState.event;
            for(let i=0; i<masterTrajectory.length; i++) {
                if(masterTrajectory[i].t > simState.t && masterTrajectory[i].event > currentEv) {
                    simStartTime = Date.now() - (masterTrajectory[i].t * 1000); 
                    actPts = []; oActPts = [];
                    for(let j=0; j<=i; j+=20) {
                        let sx = masterTrajectory[j].x; let sy = masterTrajectory[j].y;
                        actPts.push(new THREE.Vector3(sx / 10, sy / 10 + 2, 0));
                        let rScale = 100 / 6371; let r = 100 + ((sy/1000) * rScale * 2.5); let theta = (sx/1000) / 6371; 
                        oActPts.push(new THREE.Vector3(Math.sin(theta)*r, Math.cos(theta)*r, 0));
                    }
                    actTrailGeoL.setFromPoints(actPts); actTrailGeoO.setFromPoints(oActPts);
                    engineLight.intensity = 50; 
                    return;
                }
            }
        }

        // ==================================================================
        // 5. UNIFIED RENDER LOOP
        // ==================================================================
        function animateExhaust(vPitch) {
             let pos = exhaustPts.geometry.attributes.position.array;
             let sourceY = simState.event >= 4 ? 45 : -5; 
             let nozzle = new THREE.Vector3(0, sourceY, 0).applyMatrix4(rocketGroup.matrixWorld);
             let spread = 1 + (simState.y / 20000); 

             for(let i=0; i<pos.length/3; i++) {
                 let idx = i*3;
                 if(pos[idx+1] < 1 || Math.random() > 0.85) {
                     pos[idx] = nozzle.x + (Math.random()-0.5)*spread; pos[idx+1] = nozzle.y; pos[idx+2] = nozzle.z + (Math.random()-0.5)*spread;
                 } else {
                     pos[idx] -= Math.cos(vPitch) * 20 * spread; pos[idx+1] -= Math.sin(vPitch) * 20;
                 }
             }
             exhaustPts.geometry.attributes.position.needsUpdate = true;
        }

        let lastEvent = 0; let currentCamDist = 120; let currentCamOffsetX = -50; let currentCamOffsetY = 20;

        function animate() {
            requestAnimationFrame(animate);

            if(simActive && masterTrajectory.length > 0) {
                let elapsed = (Date.now() - simStartTime) / 1000;
                let exactIndex = elapsed / FIXED_DT;
                
                let idxA = Math.floor(exactIndex);
                if(idxA >= masterTrajectory.length - 1) {
                    simActive = false; clearInterval(uiInterval); document.getElementById('sys-status').innerText = "MISSION COMPLETE"; 
                    document.getElementById('btn-skip').style.display = "none"; idxA = masterTrajectory.length - 2;
                }

                let idxB = idxA + 1; let lerpFactor = exactIndex - idxA;
                let sA = masterTrajectory[idxA]; let sB = masterTrajectory[idxB]; simState = sA; 

                let vX = sA.x + (sB.x - sA.x) * lerpFactor; let vY = sA.y + (sB.y - sA.y) * lerpFactor;
                let vVy = sA.vy + (sB.vy - sA.vy) * lerpFactor; let vVx = sA.vx + (sB.vx - sA.vx) * lerpFactor;
                let vT = sA.t + (sB.t - sA.t) * lerpFactor;
                
                // --- 1. ROCKET GRAPHICS ---
                rocketGroup.position.set(vX * 0.1, vY * 0.1 + 2, 0);
                let vPitch = (sA.v > 5) ? Math.atan2(vVy, vVx) : (Math.PI/2);
                rocketGroup.rotation.z = vPitch - (Math.PI/2);

                if(Math.floor(vT * 100) % 20 === 0) {
                    actPts.push(rocketGroup.position.clone()); if(actPts.length > 800) actPts.shift(); actTrailGeoL.setFromPoints(actPts);
                    
                    let rScale = 100 / 6371; let r = 100 + ((sA.y/1000) * rScale * 2.5); let theta = (sA.x/1000) / 6371; 
                    oActPts.push(new THREE.Vector3(Math.sin(theta)*r, Math.cos(theta)*r, 0));
                    if(oActPts.length > 2000) oActPts.shift(); actTrailGeoO.setFromPoints(oActPts);
                }

                if(simState.event > lastEvent) {
                    if(simState.event === 3 || simState.event === 5) { engineLight.intensity = 50; engineLight.color.setHex(simState.event === 5 ? 0x00d2ff : 0xffaa00); }
                    lastEvent = simState.event;
                }

                // ABSOLUTE STAGING (Safe from NaN)
                if(simState.event >= 3) { 
                    let dt = Math.max(0, vT - 120); 
                    rocketGroup.userData.srbL.position.set(-2.6 - dt*0.5, 15 - Math.pow(dt, 1.2)*0.8, 0); rocketGroup.userData.srbL.rotation.z = dt * 0.05;
                    rocketGroup.userData.srbR.position.set(2.6 + dt*0.5, 15 - Math.pow(dt, 1.2)*0.8, 0); rocketGroup.userData.srbR.rotation.z = -dt * 0.05;
                }
                if(simState.event >= 4) {
                    let dt = Math.max(0, vT - 150); rocketGroup.userData.stage1.position.set(0, 20 - dt*1.5, 0); rocketGroup.userData.interstage.position.set(0, 43 - dt*1.5, 0);
                }
                if(simState.event >= 6) {
                    let dt = Math.max(0, vT - 180); 
                    rocketGroup.userData.fairingL.position.set(-dt*0.8, 63 - dt*0.5, 0); rocketGroup.userData.fairingL.rotation.z = dt * 0.05;
                    rocketGroup.userData.fairingR.position.set(dt*0.8, 63 - dt*0.5, 0); rocketGroup.userData.fairingR.rotation.z = -dt * 0.05;
                }
                if(simState.event >= 8) {
                    let dt = Math.max(0, vT - 400);
                    rocketGroup.userData.payload.position.y = 66 + dt * 1.5; rocketGroup.userData.payload.rotation.y = dt * 0.3; 
                    let foldFactor = Math.min(1.0, dt / 5.0); 
                    rocketGroup.userData.payload.children[1].rotation.z = foldFactor * (Math.PI/2);
                    rocketGroup.userData.payload.children[2].rotation.z = -foldFactor * (Math.PI/2);
                    payloadSpotlight.intensity = 2.0; // Spotlight active
                }

                if(simState.thrustKN > 0) {
                    exhaustPts.visible = true; if(engineLight.intensity > 15) engineLight.intensity -= 1; else engineLight.intensity = 15;
                    animateExhaust(vPitch + (Math.PI/2));
                } else { exhaustPts.visible = false; engineLight.intensity = 0; }

                // Auto switch to orbit view
                if(simState.event >= 8 && !hasAutoSwitchedToOrbit && vT > 405) { 
                    hasAutoSwitchedToOrbit = true; switchTab('orbit');
                }

                // --- 2. MULTI-CAMERA SYSTEM (Launch View) ---
                if(currentTab === 'launch') {
                    if(camMode === 0) { // CINEMATIC
                        let targetCamDist = 180; let targetOffsetX = -50; let targetOffsetY = 20;
                        if(simState.event >= 3 && simState.event <= 4) { targetCamDist = 100; targetOffsetX = -20; targetOffsetY = 5;} 
                        if(simState.event >= 6 && simState.event < 8) { targetCamDist = 80; targetOffsetX = -15; targetOffsetY = 5;} 
                        
                        if(simState.event >= 8) {
                            let payloadPos = new THREE.Vector3(); rocketGroup.userData.payload.getWorldPosition(payloadPos);
                            ctrlL.target.lerp(payloadPos, 0.1);
                            camL.position.lerp(new THREE.Vector3(payloadPos.x - 30, payloadPos.y + 10, payloadPos.z + 40), 0.05);
                        } else {
                            currentCamDist += (targetCamDist - currentCamDist) * 0.05; currentCamOffsetX += (targetOffsetX - currentCamOffsetX) * 0.05; currentCamOffsetY += (targetOffsetY - currentCamOffsetY) * 0.05;
                            ctrlL.target.lerp(rocketGroup.position, 0.2); 
                            camL.position.lerp(new THREE.Vector3(rocketGroup.position.x + currentCamOffsetX, rocketGroup.position.y + currentCamOffsetY, rocketGroup.position.z + currentCamDist), 0.1);
                        }
                    } else if (camMode === 1) { // ENGINE CAM
                        let upVec = new THREE.Vector3(0, 1, 0).applyQuaternion(rocketGroup.quaternion);
                        let sideVec = new THREE.Vector3(0, 0, 1).applyQuaternion(rocketGroup.quaternion);
                        let targetPos = rocketGroup.position.clone().add(upVec.multiplyScalar(-10)).add(sideVec.multiplyScalar(20));
                        camL.position.lerp(targetPos, 0.2); ctrlL.target.copy(rocketGroup.position);
                    } else if (camMode === 2) { // PAD TRACKING
                        camL.position.set(-300, 50, 400); ctrlL.target.copy(rocketGroup.position);
                    }
                }

                // --- 3. ORBIT VIEW UPDATE ---
                if(currentTab === 'orbit') {
                    earthGroup.rotation.y += 0.0005; 
                    let rScale = 100 / 6371; 
                    let r = 100 + ((simState.y/1000) * rScale * 2.5); 
                    let theta = (simState.x/1000) / 6371; 
                    orbitSatGroup.position.set(Math.sin(theta)*r, Math.cos(theta)*r, 0);
                    orbitSatGroup.rotation.z = -theta; 

                    if(simState.event >= 8) {
                        let dt = Math.max(0, simState.t - 400); let foldFactor = Math.min(1.0, dt / 5.0); 
                        orbitSatGroup.children[1].rotation.z = foldFactor * (Math.PI/2); orbitSatGroup.children[2].rotation.z = -foldFactor * (Math.PI/2);
                    }
                }
            }

            // Render active scene only (Massive Performance Boost)
            if(currentTab === 'launch' && renderer) { ctrlL.update(); renderer.render(sceneL, camL); }
            if(currentTab === 'orbit' && renderer) { ctrlO.update(); renderer.render(sceneO, camO); }
            if(currentTab === 'radar') { drawRadar(); }
        }

        // ==================================================================
        // 6. TACTICAL RADAR VIEW
        // ==================================================================
        let ctxR, rAng = 0;
        function initRadar() { ctxR = document.getElementById('radar-canvas').getContext('2d'); }
        function drawRadar() {
            let cvs = document.getElementById('radar-canvas'); let cont = document.getElementById('radar-container');
            if (cvs.width === 0) return;
            
            let w = cvs.width, h = cvs.height; let cx = w/2, cy = h/2, maxR = Math.min(cx, cy) - 40;
            ctxR.fillStyle = 'rgba(2, 5, 10, 0.4)'; ctxR.fillRect(0,0,w,h);
            ctxR.strokeStyle = 'rgba(0, 240, 255, 0.15)'; ctxR.lineWidth = 1; ctxR.setLineDash([5, 5]);
            for(let i=1; i<=4; i++) { ctxR.beginPath(); ctxR.arc(cx,cy,(maxR/4)*i,0,Math.PI*2); ctxR.stroke(); }
            
            rAng -= 0.04; ctxR.save(); ctxR.translate(cx,cy); ctxR.rotate(rAng);
            let grad = ctxR.createConicGradient(0,0,0); grad.addColorStop(0, 'rgba(0, 240, 255, 0.5)'); grad.addColorStop(0.15, 'transparent');
            ctxR.fillStyle = grad; ctxR.beginPath(); ctxR.moveTo(0,0); ctxR.arc(0,0,maxR,0,Math.PI/4); ctxR.fill(); ctxR.restore();
            
            if(simState) {
                let rScale = maxR / 4500; 
                let rx = cx + (simState.x / 1000) * rScale; let ry = cy - (simState.y / 1000) * rScale;
                ctxR.beginPath(); ctxR.fillStyle = '#00f0ff'; ctxR.shadowBlur = 15; ctxR.shadowColor = '#00f0ff';
                ctxR.arc(rx, ry, 5, 0, Math.PI*2); ctxR.fill(); ctxR.shadowBlur = 0;
                let gx = cx + (simState.gsX / 1000) * rScale; let gy = cy - (simState.gsY / 1000) * rScale;
                ctxR.beginPath(); ctxR.fillStyle = '#ff2a2a'; ctxR.fillRect(gx-3, gy-3, 6, 6);
            }
        }

        window.onload = () => { initWebGL(); initRadar(); };
    </script>
</body>
</html>
